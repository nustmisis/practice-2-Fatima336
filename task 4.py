#<b>Задание 4.</b>

#Взгляните на показанный ниже
#код, в котором используется цикл while и флаг found
#для поиска в списке тепеней 2 занания 2, вовзевдённую в пятую степень


L = [1, 2, 4, 8, 16, 32, 64]
X = 5
found = False
i = 0
while not found and i < len(L) :
    if 2 ** X == L[i] :
        found = True
    else:
        i = i + 1

if found:
    print('at index', i)
else:
    print(X, 'not found')
    
#Код явно написан с использование альетрнативной логики.

#Попоробуйте оптимизировать код c использование рекомендаций, ониявляются не обезатальными, но помогут понять основные ошибки.

#а)Сначала перепишите код с конструкцией else цикла while, чтобы избавиться от флага found и финального оператора if.

#б) Затем перепишите код для использования цикла for с конструкцией else,
#чтобы избавиться от явной логики индексации списка. (Подсказка: для получения индекса элемента применяйте списковый метод index — L. index (X)
#возвращает смещение первого элемента X в списке L.)

#в) Далее полностью устраните цикл, переписав код с использованием простого
#выражения с операцией членства in. (За дополнительными сведениями обращайтесь в главу 8 или наберите для тестирования 2 in [1,2,3].)
#
#г) Наконец примените цикл for и списковый метод append для генерации списка степеней 2 (L) вместо жесткого кодирования спискового литерала.
#Ниже приведены более глубокие рассуждения.

#д) Как вы думаете, улучшит ли производительность перенос выражения 2 ** X
#за пределы циклов? Каким образом вы представили бы это в коде?

#е)  Python содержит инструмент тар (функция, список), который также способен генерировать список степеней 2:. Каким образом можно его задать ?
#<b>Пункт а</b>
import math
L = [1, 2, 4, 8, 16, 32, 64]
x = 5
i = 0
while i < len(L):
    if math.log(L[i], 2) == x:
        print('at index', i)
        i = len(L)
    else:
        i+=1
#<b>Пункт б</b>
L = [1, 2, 4, 8, 16, 32, 64]
x = 5
if (L.index(L[5], 0, -1)) is not False:
    print('at index', L.index(L[5], 0, -1))
else:
    print(x, 'not found')
#<b>Пункт в</b>
L = [1, 2, 4, 8, 16, 32, 64]
x = 5
if (2 ** x in L):
    print('at index', L.index(L[5], 0, -1))
else:
    print(x, 'not found')
#<b>Пункт г</b>
L = [1, 2, 4, 8, 16, 32, 64]
x = 5
degrees = []
for i in range(len(L)):
    degrees.append(math.log(L[i], 2))
    
if (x in degrees) is True:
    print('at index', L.index(L[5], 0, -1))
else:
    print(x, 'not found')
#<b>Пункт д</b>

#Я считаю, что перенос выражения 2 ** X за пределы цикла улучшит производительность кода, потому что не придется проходить по каждой итерации цикла. Тогда код может быть представлен следующим образом:
L = [1, 2, 4, 8, 16, 32, 64]
x = 5
if (2 ** x in L):
    print('at index', L.index(L[5], 0, -1))
else:
    print(x, 'not found')
#Проверка производительности:
import time
start_time = time.time()
L = [1, 2, 4, 8, 16, 32, 64]
x = 5
if (2 ** x in L):
    print('at index', L.index(L[5], 0, -1))
else:
    print(x, 'not found')
print('time elapsed:', time.time() - start_time)
import time
start_time = time.time()
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
found = False
i = 0
while not found and i < len(L) :
    if 2 ** X == L[i] :
        found = True
    else:
        i = i + 1

if found:
    print('at index', i)
else:
    print(X, 'not found')
print('time elapsed:', time.time() - start_time)
#<b>Пункт е</b>
L = [1, 2, 4, 8, 16, 32, 64]
X = 5
if pow(2, x) in L:
    print('at index', L.index(L[5], 0, -1))
else:
    print(x, 'not found')